package org.planit.graph;

import java.util.HashSet;
import java.util.Set;
import java.util.logging.Logger;

import org.planit.utils.exceptions.PlanItException;
import org.planit.utils.graph.DirectedGraph;
import org.planit.utils.graph.DirectedVertex;
import org.planit.utils.graph.Edge;
import org.planit.utils.graph.EdgeSegment;
import org.planit.utils.graph.EdgeSegments;
import org.planit.utils.graph.Graph;
import org.planit.utils.graph.Vertex;
import org.planit.utils.id.IdGenerator;
import org.planit.utils.id.IdGroupingToken;

/**
 * Create network entities with direction for a physical network simulation model
 * 
 * @author markr
 *
 */
public class DirectedGraphBuilderImpl implements DirectedGraphBuilder<DirectedVertex, Edge, EdgeSegment> {

  private static final Logger LOGGER = Logger.getLogger(DirectedGraphBuilderImpl.class.getCanonicalName());

  /** use graph builder impl for overlapping functionality */
  private final GraphBuilderImpl graphBuilder = new GraphBuilderImpl();

  /**
   * Contiguous id generation within this group id token for all instances created with factory methods in this class
   */
  protected IdGroupingToken groupId;

  /**
   * Remove id gaps from available edge segments by renumbering all of them and updating the registration
   * 
   * @param edgeSegments to recreated ids for
   */
  protected void removeIdGaps(EdgeSegments<? extends Edge, ? extends EdgeSegment> edgeSegments) {
    /* remove gaps by simply resetting and recreating all edge segment ids */
    IdGenerator.reset(getIdGroupingToken(), EdgeSegment.class);

    for (EdgeSegment edgeSegment : edgeSegments) {
      if (edgeSegment instanceof EdgeSegmentImpl) {
        ((EdgeSegmentImpl) edgeSegment).setId(EdgeSegmentImpl.generateEdgeSegmentId(getIdGroupingToken()));
      } else {
        LOGGER.severe(String.format("attempting to reset id on edgse segment (%s) that is not compatible with the edge implementation generated by this builder, ignored",
            edgeSegment.getClass().getCanonicalName()));
      }
    }
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public DirectedVertex createVertex() {
    return new DirectedVertexImpl(groupId);
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public Edge createEdge(DirectedVertex vertexA, DirectedVertex vertexB, final double length) throws PlanItException {
    return graphBuilder.createEdge(vertexA, vertexB, length);
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public EdgeSegment createEdgeSegment(Edge parentEdge, boolean directionAB) throws PlanItException {
    return new EdgeSegmentImpl(groupId, parentEdge, directionAB);
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public void setIdGroupingToken(IdGroupingToken groupToken) {
    graphBuilder.setIdGroupingToken(groupToken);
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public IdGroupingToken getIdGroupingToken() {
    return graphBuilder.getIdGroupingToken();
  }

  /**
   * {@inheritDoc}
   */
  @SuppressWarnings("unchecked")
  @Override
  public void removeSubNetwork(Graph<DirectedVertex, Edge> graph, Set<DirectedVertex> subNetworkToRemove) {
    /* cast to base classes and call graph builder implementation to deal with basic vertices and edges removal */
    Graph<Vertex, Edge> castGraph = (Graph<Vertex, Edge>) ((Graph<? extends Vertex, Edge>) graph);
    Set<Vertex> castSubNetworkToRemove = (Set<Vertex>) ((Set<? extends Vertex>) subNetworkToRemove);
    graphBuilder.removeSubNetwork(castGraph, castSubNetworkToRemove);
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public void removeSubNetwork(DirectedGraph<DirectedVertex, Edge, EdgeSegment> directedGraph, Set<DirectedVertex> subNetworkToRemove) {

    /* remove the subnetwork from the actual network */
    for (DirectedVertex directedVertex : subNetworkToRemove) {
      Set<EdgeSegment> entryEdgeSegments = new HashSet<EdgeSegment>(directedVertex.getEntryEdgeSegments());
      Set<EdgeSegment> exitEdgeSegments = new HashSet<EdgeSegment>(directedVertex.getExitEdgeSegments());

      /* remove vertex' edge segments from graph */
      entryEdgeSegments.forEach(edgeSegment -> directedGraph.getEdgeSegments().remove(edgeSegment));
      exitEdgeSegments.forEach(edgeSegment -> directedGraph.getEdgeSegments().remove(edgeSegment));

      /* remove edge segments from directed vertex */
      entryEdgeSegments.forEach(edgeSegment -> directedGraph.getEdgeSegments().remove(edgeSegment));
      exitEdgeSegments.forEach(edgeSegment -> directedGraph.getEdgeSegments().remove(edgeSegment));

      /* remove edge segments from vertex */
      entryEdgeSegments.forEach(edgeSegment -> directedVertex.removeEdgeSegment(edgeSegment));
      exitEdgeSegments.forEach(edgeSegment -> directedVertex.removeEdgeSegment(edgeSegment));
    }

    /* ensure no id gaps remain after the removal of internal entities */
    if (directedGraph.getEdgeSegments() instanceof EdgeSegmentsImpl<?, ?>) {
      removeIdGaps((EdgeSegmentsImpl<?, ?>) directedGraph.getEdgeSegments());
    } else {
      LOGGER.severe(
          "expected the EdgeSegments implementation to be compatible with directed graph builder, this is not the case: unable to correctly remove subnetwork and update ids");
    }

    /* do the same for vertices and edges */
    removeSubNetwork((Graph<DirectedVertex, Edge>) directedGraph, subNetworkToRemove);
  }

}
