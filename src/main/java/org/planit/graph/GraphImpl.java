package org.planit.graph;

import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Logger;

import org.planit.utils.graph.Edge;
import org.planit.utils.graph.Edges;
import org.planit.utils.graph.Graph;
import org.planit.utils.graph.Vertex;
import org.planit.utils.graph.Vertices;
import org.planit.utils.id.IdGenerator;
import org.planit.utils.id.IdGroupingToken;

/**
 * 
 * A graph implementation consisting of vertices and edges
 * 
 * @author markr
 *
 */
public class GraphImpl<V extends Vertex, E extends Edge> implements Graph<V, E>, GraphModifier<V> {

  /** the logger */
  @SuppressWarnings("unused")
  private static final Logger LOGGER = Logger.getLogger(GraphImpl.class.getCanonicalName());

  /**
   * The id of this graph
   */
  private final long id;

  // Protected

  /**
   * Graph builder responsible for constructing all graph related (derived) instances
   */
  protected final GraphBuilder<V, E> graphBuilder;

  // PUBLIC

  /**
   * class instance containing all edges
   */
  protected final Edges<V, E> edges;

  /**
   * class instance containing all vertices
   */
  protected final Vertices<V> vertices;

  /**
   * Remove id gaps from available edges by renumbering all of them and updating the registration
   * 
   * @param edges to recreated ids for
   */
  protected void removeIdGaps(Edges<? extends Vertex, ? extends Edge> edges) {
    /* remove gaps by simply resetting and recreating all edge ids */
    IdGenerator.reset(getGraphIdGroupingToken(), Edge.class);

    for (Edge edge : edges) {
      if (edge instanceof EdgeImpl) {
        ((EdgeImpl) edge).setId(EdgeImpl.generateEdgeId(getGraphIdGroupingToken()));
      } else {
        LOGGER.severe(String.format("attempting to reset id on edge (%s) that is not compatible with the edge implementation generated by this builder, ignored",
            edge.getClass().getCanonicalName()));
      }
    }
  }

  /**
   * Remove id gaps from available verrtices by renumbering all of them and updating the registration
   * 
   * @param vertices to recreated ids for
   */
  protected void removeIdGaps(Vertices<? extends Vertex> vertices) {
    /* remove gaps by simply resetting and recreating all vertex ids */
    IdGenerator.reset(getGraphIdGroupingToken(), Vertex.class);

    for (Vertex vertex : vertices) {
      if (vertex instanceof VertexImpl) {
        ((VertexImpl) vertex).setId(VertexImpl.generateVertexId(getGraphIdGroupingToken()));
      } else {
        LOGGER.severe(String.format("attempting to reset id on vertex (%s) that is not compatible with the edge implementation generated by this builder, ignored",
            vertex.getClass().getCanonicalName()));
      }
    }
  }

  /**
   * helper function for recursive subnetwork identification
   * 
   * @param referenceVertex    to process
   * @param subNetworkVertices to add connected adjacent nodes to
   */
  @SuppressWarnings("unchecked")
  protected void processSubNetworkVertex(V referenceVertex, Set<V> subNetworkVertices) {
    if (!subNetworkVertices.contains(referenceVertex)) {
      subNetworkVertices.add(referenceVertex);

      Collection<? extends Edge> edges = referenceVertex.getEdges();
      for (Edge edge : edges) {
        if (!subNetworkVertices.contains(edge.getVertexA())) {
          processSubNetworkVertex((V) edge.getVertexA(), subNetworkVertices);
        }
        if (!subNetworkVertices.contains(edge.getVertexB())) {
          processSubNetworkVertex((V) edge.getVertexB(), subNetworkVertices);
        }
      }
    }
  }

  /**
   * Graph Constructor
   *
   * @param groupId        contiguous id generation within this group for instances of this class
   * @param networkBuilder the builder to be used to create this network
   */
  public GraphImpl(final IdGroupingToken groupId, final GraphBuilder<V, E> graphBuilder) {
    this.id = IdGenerator.generateId(groupId, GraphImpl.class);
    this.graphBuilder = graphBuilder;

    IdGroupingToken groupToken = IdGenerator.createIdGroupingToken(this, this.getId());
    this.graphBuilder.setIdGroupingToken(groupToken);

    this.edges = new EdgesImpl<V, E>(graphBuilder);
    this.vertices = new VerticesImpl<V>(graphBuilder);
  }

  // Getters - Setters

  /**
   * {@inheritDoc}
   */
  @Override
  public long getId() {
    return this.id;
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public Vertices<V> getVertices() {
    return vertices;
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public Edges<V, E> getEdges() {
    return edges;
  }

  /**
   * Collect the id grouping token used for all entities registered on the graph, i.e., this network's specific identifier for generating ids unique and contiguous within this
   * network and this network only
   * 
   * @return the graph id grouping token
   */
  public IdGroupingToken getGraphIdGroupingToken() {
    return this.graphBuilder.getIdGroupingToken();
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public void removeDanglingSubGraphs(Integer belowsize) {
    Set<Integer> removedSubnetworksOfSize = new HashSet<Integer>();

    Set<V> remainingVertices = new HashSet<V>(getVertices().size());
    getVertices().forEach(vertex -> remainingVertices.add(vertex));
    Map<V, Integer> identifiedSubNetworkSizes = new HashMap<V, Integer>();

    while (remainingVertices.iterator().hasNext()) {
      /* recursively traverse the subnetwork */
      V referenceVertex = remainingVertices.iterator().next();
      Set<V> subNetworkVerticesToPopulate = new HashSet<V>();
      processSubNetworkVertex(referenceVertex, subNetworkVerticesToPopulate);

      /* register size and remove subnetwork from remaining nodes */
      identifiedSubNetworkSizes.put(referenceVertex, subNetworkVerticesToPopulate.size());
      remainingVertices.removeAll(subNetworkVerticesToPopulate);
    }

    /* remove all non-dominating subnetworks */
    int maxSubNetworkSize = Collections.max(identifiedSubNetworkSizes.values());
    for (Entry<V, Integer> entry : identifiedSubNetworkSizes.entrySet()) {
      int subNetworkSize = entry.getValue();
      if (maxSubNetworkSize > subNetworkSize) {
        /* not the biggest subnetwork, remove from network if below threshold */
        if (subNetworkSize < belowsize) {
          removeSubGraphOf(entry.getKey());
          removedSubnetworksOfSize.add(subNetworkSize);
        }
      }
    }

    if (belowsize != Integer.MAX_VALUE) {
      LOGGER.info(String.format("removed %d dangling networks", removedSubnetworksOfSize));
    } else {
      LOGGER.info(String.format("removed %d dangling networks of size %d or less", removedSubnetworksOfSize, belowsize));
    }

  }

  /**
   * {@inheritDoc}
   */
  @SuppressWarnings("unchecked")
  @Override
  public void removeSubGraph(Set<V> subGraphToRemove) {

    /* remove the subnetwork from the actual network */
    for (V vertex : subGraphToRemove) {
      Set<Edge> vertexEdges = new HashSet<Edge>(vertex.getEdges());

      /* remove vertex' edges from graph */
      vertexEdges.forEach(edge -> getEdges().remove((E) edge));
      /* remove vertex from graph */
      getVertices().remove(vertex);

      /* remove edges from vertex */
      vertexEdges.forEach(edge -> vertex.removeEdge(edge));

      /* remove vertex from edge */
      vertexEdges.forEach(edge -> edge.removeVertex(vertex));
    }

    /* ensure no id gaps remain after the removal of internal entities */
    if (getEdges() instanceof EdgesImpl<?, ?>) {
      removeIdGaps((EdgesImpl<?, ?>) getEdges());
    } else {
      LOGGER.severe("expected the Edges implementation to be compatible with graph builder, this is not the case: unable to correctly remove subnetwork and update ids");
    }

    if (getVertices() instanceof VerticesImpl<?>) {
      removeIdGaps((VerticesImpl<?>) getVertices());
    } else {
      LOGGER.severe("expected the Vertices implementation to be compatible with graph builder, this is not the case: unable to correctly remove subnetwork and update ids");
    }
  }

  /**
   * remove the (sub)graph in which the passed in vertex resides. Apply reordering of internal ids of remaining network.
   * 
   * @param referenceVertex to identify subnetwork by
   */
  public void removeSubGraphOf(V referenceVertex) {
    Set<V> subNetworkNodesToRemove = new HashSet<V>();
    processSubNetworkVertex(referenceVertex, subNetworkNodesToRemove);
    removeSubGraph(subNetworkNodesToRemove);
  }

}
